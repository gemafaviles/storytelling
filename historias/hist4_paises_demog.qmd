---
title: "¡Nos vamos a Noruega!"
author:
  - Gema Fernández-Avilés (Gema.FAviles@uclm.es)
  - Isidro Hidalgo (Isidro.Hidalgo@uclm.es)
format:
  html:
    theme: cerulean
    highlight-style: ayu-mirage
    self-contained: true
    date: "`r Sys.Date()`"
    embed-resources: true
    toc-title: Summary
    toc: true
    number-sections: true
    preview-links: auto
    code-link: true
number-sections: true
execute:
  echo: true
  eval: true
  output: true
  include: true
  freeze: auto
  fig-height: 5
  warning: false
  comment: "#>"
  code-line-numbers: true
  code-copy: true
  code-overflow: scroll
---

::: {.callout-note}
Los datos que se utilizan en esta historia están disponibles en el repositorio GitHub "From data to viz": https://github.com/holtzy/data_to_viz.
:::

# ¡Nos vamos a Noruega!

Mi jefe quiere que le haga un análisis exploratorio (eso dice, pero siempre quiere gráficos guays con conclusiones interesantes...) de unos datos demográficos por países. Lo peor es que quiere que le acompañe a Noruega, que hay un workshop "fantástico" [sic]...

Con el frío que hace ahora en Noruega... Pero este hombre, ¿por qué no elige estas cosas con más criterio y nos vamos a Hawai? ¡Por ejemplo!

# Entender el contexto

::: {.callout-tip}

## Cómo definir el propósito y la audiencia de tu análisis

En este caso, puesto que lo que me pide el jefe es un análisis exploratorio, se trata simplemente de encontrar relaciones interesantes entre variables, mirar su evolución, por si se ven cosas interesantes, y preparar gráficos que vayan al grano, como ya sabemos hacer... ¡Que para algo sirven los cursos de la UCLM!
:::

```{r}
#| code-summary: Configuración inicial y datos

library(tidyverse)
library(GGally)
library(NbClust)
library(igraph)
library(factoextra)
library(corrplot)
library(explore)

# Load data
demog_data <- read.table("https://raw.githubusercontent.com/holtzy/data_to_viz/master/Example_dataset/multivariate.csv", header = T, sep = ";")

colnames(demog_data) <- gsub("\\.", "_", colnames(demog_data))
names(demog_data)[9] <- "Population_aged_65"
head(demog_data)
```

```{r}
#| code-summary: Exploración básica

summary(demog_data)
demog_data |> explore_all()
```

# Elegir una visualización adecuada

::: {.callout-tip}
## Selección de gráficos y visualizaciones que mejor representen tus datos.
:::

Podemos comenzar por una matriz de puntos de las variables cuantitativas. El paquete `GGally` ofrece una visualización muy elaborada para un primer vistazo con la función `ggpairs()`...

```{r}
#| code-summary: matriz de puntos

demo_cuanti <- demog_data |>
   select(Pop, Birth_rate, Mortality_rate, Life_expectancy,
          Infant_mortality, Children_per_woman,  Growth_rate,
          Population_aged_65) |>
   na.omit()

demo_cuanti |> 
   ggpairs(progress = FALSE)
```

Hay muchas asociaciones interesantes entre diferentes variables. Aquí ya vemos mucha tela que cortar. Por no extendernos, analizaremos una de las relaciones más adelante. Pero primero, es muy interesante ver la matriz de correlaciones que, aunque con `ggpairs()` teníamos ya una primera impresión, el paquete `corrplot` nos ofrece una visualización ideal con la función `corrplot.mixed()`:

## Matriz de correlaciones

```{r}
demo_cuanti |> 
  cor() |> 
  corrplot.mixed( order = 'AOE')
```

## Gráfico de puntos entre `Growth_rate` y `Life_expectancy`

Como ejemplo, vamos a ver la relación entre la esperanza de vida y la tasa de crecimiento, que ya hemos visto que existe. Empecemos con un gráfico de puntos...

```{r}
#| code-summary: gráfico de puntos

demog_data  |>
  ggplot(aes(x = Growth_rate, y = Life_expectancy)) +
  geom_point() +
  labs(title = "Esperanza de vida vs. Tasa de crecimiento",
       x = "Tasa de crecimiento",
       y = "Esperanza de vida") +
  theme_minimal()
```

# Eliminar el desorden. Enfocar la atención

En el gráfico anterior no se ve casi nada... solo una ligera tendencia parabólica, pero no sabemos nada de los puntos, ese gráfico aporta poco.

¿Qué herramientas tenemos a nuestro alcance para poner el foco sobre lo que nos interesa? Aquí podemos usar la estética y las facetas, para separar los puntos y dar más información a través de la visualización. Veamos...

## Herramienta 1: la estética

```{r}
#| code-summary: gráfico de puntos mejorado por estética

demog_data  |>
  ggplot(aes(x = Growth_rate, y = Life_expectancy, size = Pop,
             color = Continent)) +
  geom_point(alpha=0.5) +
  scale_size(range = c(.1, 20)) +
  labs(title = "De Europa a Norteamérica, Oceanía, Sudamérica y África, a través de Asia",
       x = "Tasa de crecimiento",
       y = "Esperanza de vida") +
  theme_minimal() +
  theme(axis.title.x = element_text(hjust = 0),
        axis.title.y = element_text(hjust = 1))
```
Estamos usando **dos variables para enfocar la atención aportando información: el tamaño del país y el continente**. Solo con eso vemos enseguida por donde van los tiros: la mayor parte de los países de Europa tienen gran esperanza de vida y crecimiento moderado. Por el contrario, Sudamérica tiene tasas de crecimiento muy elevadas (son países en fases de expansión económica) y una menor esperanza de vida, a falta de consolidar sanidad y otros servicios en general.

También somos capaces de identificar China e India rápidamente, por su tamaño, y Japón arriba a la izquierda por su tamaño medio-grande y enorme esperanza de vida.

Sin embargo, hay colores muy parecidos, que exigen demasiada atención. Podemos usar la siguiente herramienta...

## Herramienta 2: facetas

Otra forma de eliminar el desorden y enfocar la atención es usar facetas, separando el gráfico según una o más variables interesantes. En este caso usamos solo el continente:

```{r}
#| code-summary: gráfico de puntos mejorado por facetas

demog_scatter <- ggplot(data = demog_data, # data
              aes(x = Growth_rate, y = Life_expectancy, colour = Continent)) + #aesthetics
    geom_point(alpha = 0.5) + #geometries
    facet_wrap(~ Continent, scales = "free") + #facets
    labs(title = "Life expectancy at birth vs. Per capita GDP", 
         x = "Growth_rate", y = "Life_expectancy", colour = "Continent") + #labels
    theme_light() #themes

demog_scatter 
```

::: {#exr-1}
¿Qué problema podría tener este gráfico?
:::

::: {.callout-pista}
pista: fijaros en los ejes
:::

Exacto: las escalas. Pero hemos dicho "podría", no que tenga un problema en sí. Cuando nuestra intención es mirar dentro de cada faceta para ver la relación entre las variables, es posible que nos interese dejarlo como está.

Pero muchas veces es muy importante, cuando usamos facetas, que podamos comparar los diferentes grupos entre sí. En este caso, es imprescindible usar la misma escala en todas las facetas. Para ello, hay que especificar los límites de las escalas de los ejes.

¿Existe una forma fácil de saber cuáles poner? Claro, con un `summary()` de las variables, tal como indicamos a continuación:

```{r}
#| code-summary: mejoramos la escala para comparar facetas

summary(demog_data$Life_expectancy)
summary(demog_data$Growth_rate)

demog_scatter_escala <- ggplot(data = demog_data,
                               aes(x = Growth_rate,
                                   y = Life_expectancy,
                                   colour = Continent)) +
  geom_point(alpha = 0.5) +
  facet_wrap(~ Continent, scales = "free") +
  labs(title = "Esperanza de vida respecto al PIB per capita",
       x = "Tasa de crecimiento", y = "Esperanza de vida",
       colour = "Continent") +
  scale_x_continuous(limits = c(-10, 45)) +
  scale_y_continuous(limits = c(45, 85)) +
  theme_light()

demog_scatter_escala 
```

## Linea de suavizado

A veces, si hay una tendencia evidente, es conveniente usar una línea de suavizado que la identifique. En este caso, no está nada clara, por lo que la podemos omitir. Y aquí sí es interesante dejar libre la escala, para maximizar la visualización de la tendencia, que es lo que nos interesa:

```{r}
#| code-summary: añadimos línea de suavizado

demog_scatter + geom_smooth(method = NULL, se = TRUE) 
```

## Técnicas de segmentación: clusters

Una forma de usar las variables en el análisis exploratorio es agrupar los registros haciendo segmentación. Los clusters se prestan a visualizaciones muy sofisticadas, pero hay que tener cuidado de simplificarlas, porque si no el desorden puede estropear el mensaje. Veamos qué podemos hacer...

```{r}
#| code-summary: preparamos los datos para el clúster

cluster_data <- demog_data |>
  select(Country) |> # añade esta variable a las cuantitativas
  cbind(demo_cuanti) |>
  column_to_rownames(var = "Country")

head(cluster_data)
```

Ahora ya podemos empezar la segmentación. Lo primero es estandarizar las variables para impedir que las de mayor rango (distancia entre mínimo y máximo) acaparen demasiado protagonismo...

```{r}
#| code-summary: estandarizamos y calculamos las distancias

cluster_data_stand <- scale(cluster_data)
d_euclidea <- get_dist(x = cluster_data_stand,
                       method = "euclidea")
fviz_dist(dist.obj = d_euclidea, lab_size = 5)
```

Se aprecian agrupaciones entre países, pero...

::: {#exr-1}
...aquí se ve muy poco, de tanta información que hay... ¿qué variable es la culpable?
:::

Aquí conviene hacerse una pregunta: ¿es suficiente agrupar los países por la variable `Group`, que va asociada a la ubicación del país? Si es así, calculamos las medias de las variables por grupo y simplificamos mucho la visualización. Si es imprescindible usar el país, hay que apechugar, porque no hay forma de evitar más de 200 registros...

```{r}
#| code-summary: probamos la segmentación por grupos de países

cluster_data_group <- demog_data |>
  select(Group) |> # añade esta variable a las cuantitativas
  cbind(demo_cuanti) |>
  group_by(Group) |>
  mutate(across(where(is.numeric), mean)) |>
  unique()


cluster_data_group_stand <- scale(cluster_data_group)
d_euclidea_group <- get_dist(x = cluster_data_group_stand,
                       method = "euclidea")
fviz_dist(dist.obj = d_euclidea_group, lab_size = 5)
```

```{r}
#| code-summary: estimación del k óptimo

set.seed(2025)

num_cluster <- NbClust(cluster_data_stand, distance = "euclidean", method = "ward.D2", min.nc = 2, max.nc = 10)

num_cluster$Best.nc
head(num_cluster$Best.partition)
table(num_cluster$Best.partition)
```




```{r}
hc_ward <- hcut(cluster_data_stand , k = 6, hc_method = "ward.D2")
fviz_dend(hc_ward, cex = 0.5, k = 6, main = "Cluster jerárquico simple")
```
¿Lo mejoramos?

```{r}
set.seed(5665)
hc_ward <- hcut(cluster_data_stand, k = 6, hc_method = "ward.D2")

fviz_dend(
  x = hc_ward,
  k = 7,
  type = "circular",
  cex=0.5
)
```


### K-means

```{r}
set.seed(123)
eclust(cluster_data_stand, "kmeans", k = 3)
```




